<?php
/*
 * Gallery - a web based photo album viewer and editor
 * Copyright (C) 2000-2007 Bharat Mediratta
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or (at
 * your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA  02110-1301, USA.
 */
/**
 * @package map
 * @author Eric Daniel <ehdaniel@gmail.com>
 * @version $Revision: 1576 $
 *
 * based on a code from Alan Harder <alan.harder@sun.com>
 */
/*
 * Session key for storing item admin mode
 */
define('map_SESSION_KEY', 'map.adminMode.itemId');

GalleryCoreApi::requireOnce('modules/map/classes/mapInterface_1_0.class');
GalleryCoreApi::requireOnce('modules/map/classes/GoogleMapUtilities.class');

/**
 * A helper class for the map module.
 *
 * @package map
 * @subpackage Classes
 */
class mapHelper extends mapInterface_1_0 /* and GalleryEventListener */ {

    /**
     * Load and decode module parameters
     *
     * @param int id of container; check for album-specific settings
     * @param boolean fallback to site-defaults if no album-specific settings found
     * @param array sets to load; all by default
     * @return array GalleryStatus a status code
     *               mixed containing custom field data
     *               boolean true if album-specific settings are returned
     * @static
     */
    function loadParameters($containerId = 0, $fallback = true,
			    $sets = array('common', 'album', 'photo')) {
	$isContainer = ($containerId > 0);
	list ($ret, $param) =
	    GalleryCoreApi::fetchAllPluginParameters('module', 'map', $containerId);
	if ($ret) {
	    return array($ret->wrap(__FILE__, __LINE__), null, null);
	}
	if (empty($param) && $containerId > 0 && $fallback) {
	    list ($ret, $param) = GalleryCoreApi::fetchAllPluginParameters('module', 'map');
	    if ($ret) {
		return array($ret->wrap(__FILE__, __LINE__), null, null);
	    }
	    $isContainer = false;
	}
	foreach ($sets as $set) {
	    $result[$set] = array();
	    foreach ((!empty($param[$set]) ? explode('|', $param[$set]) : array()) as $tmp) {
		$list = explode('`', $tmp);
		$result[$set][] = array('field' => $list[0],
					'summary' => ($list[1] == '1'),
					'detail' => ($list[2] == '1'),
					'choices' => array_splice($list, 3));
	    }
	}
	return array(null, $result, $isContainer);
    }

    /**
     * Encode and save module parameters
     *
     * @param array data to save
     * @param int id of container; to save album-specific settings
     * @return GalleryStatus a status code
     * @static
     */
    function saveParameters($param, $containerId = 0) {
	foreach (array('common', 'album', 'photo') as $set) {
	    if (!isset($param[$set])) {
		continue;
	    }
	    $list = array();
	    /** @todo: fix this to use serialize/unserialize */
	    foreach ($param[$set] as $item) {
		$list[] = $item['field'] . '`' . ($item['summary'] ? 1 : 0) . '`'
			  . ($item['detail'] ? 1 : 0)
			  . (!empty($item['choices']) ? ('`' . implode('`', $item['choices'])) 
						      : '');
	    }
	    $ret = GalleryCoreApi::setPluginParameter('module', 'map', $set,
						      implode('|', $list), $containerId);
            if ($ret) {
                 return $ret->wrap(__FILE__, __LINE__);
            }
	}
	return null;
    }

    /**
     * Add new custom field in given set/container.
     *
     * @param string field name
     * @param string set (common, album, photo)
     * @param int id of container; to save album-specific settings
     * @return array object GalleryStatus a status code
     *               boolean true on success, false on duplicate field name
     * @static
     */
    function addField($newField, $set, $containerId = 0) {
	list ($ret, $param) = mapHelper::loadParameters($containerId, false);
        if ($ret) {
             return $ret->wrap(__FILE__, __LINE__);
        }
	foreach ($param as $list) {
	    $idx = mapHelper::findParameter($list, $newField);
	    if ($idx >= 0) {
		return array(null, false);
	    }
	}
	$param[$set][] = array('field' => $newField,
			       'summary' => false, 'detail' => true, 'choices' => array());
	$ret = mapHelper::saveParameters(array($set => $param[$set]), $containerId);
        if ($ret) {
             return $ret->wrap(__FILE__, __LINE__);
        }
	return array(null, true);
    }

    /**
     * Find a field in a parameter list
     *
     * @param array parameter list
     * @param string field to find
     * @return int index or -1 if not found
     * @static
     */
    function findParameter(&$list, $field) {
	foreach ($list as $i => $item) {
	    if ($item['field'] == $field) {
		return $i;
	    }
	}
	return -1;
    }

    /**
     * Delete custom field values for given field
     *
     * @param string field to delete
     * @param int id of container, to delete only for specific album
     * @param string 'album' or 'photo' -- don't delete values for items of this type
     * @return GalleryStatus a status code
     * @static
     */
    function deleteField($field, $containerId = 0, $exceptType = '') {

	switch ($exceptType) {

	case 'album':
	    $setTypes = array(0, 2);
	case 'photo':
	    if (!isset($setTypes)) {
		$setTypes = array(0, 1);
	    }
	    $ret = GalleryCoreApi::removeMapEntry('mapMap',
		    array('field' => $field, 'setId' => $containerId, 'setType' => $setTypes) );
	    if ($ret) {
		return $ret->wrap(__FILE__, __LINE__);
	    }
	    break;

	default:
	    $ret = GalleryCoreApi::removeMapEntry('mapMap',
		    array('field' => $field, 'setId' => $containerId) );
	    if ($ret) {
		return $ret->wrap(__FILE__, __LINE__);
	    }
	}
	return null;
    }

    /**
     * Load custom field values for specified items
     *
     * @param array  object GalleryEntity item, ...
     * @param string if specified then only include fields for that view (summary or detail)
     * @param string if specified then include in results all valid fields for
     *               this type, even if item has no value
     * @return array GalleryStatus a status code
     *               array(itemId => array(field => value))
     *               array(itemId => array) loadParameters results
     *		     array(itemId => boolean) loadParameters results
     * @static
     */
    function fetchFieldValues($items, $viewType = null, $fillSet = null) {
	global $gallery;
	$data = $result = array();

	if (empty($items) || !is_array($items)) {
	    return array(GalleryCoreApi::error(ERROR_BAD_PARAMETER, __FILE__, __LINE__),
			 null, null, null);
	}

	foreach ($items as $item) {
	    $itemId = (int)$item->getId();
	    $itemIds[] = $itemId;
	    $result[$itemId] = array();
	    $containerId =
		GalleryUtilities::isA($item, 'GalleryAlbumItem') ? (int)$itemId 
								 : (int)$item->getParentId();

	    list ($ret, $param[$itemId], $isContainer[$itemId]) =
		mapHelper::loadParameters($containerId);
	    if ($ret) {
		return array($ret, null);
	    }
	}

	$query = '
	SELECT [mapMap::itemId], [mapMap::field], [mapMap::value]
	FROM [mapMap]
	WHERE [mapMap::itemId] IN (' . GalleryUtilities::makeMarkers($itemIds) . ')';

	list ($ret, $searchResults) = $gallery->search($query, $itemIds);
	if ($ret) {
	    return array($ret, null);
        }

	while ($rec = $searchResults->nextResult()) {
	    $data[(int)$rec[0]][$rec[1]] = $rec[2];
	}

	foreach ($itemIds as $itemId) {
	    foreach (array('common', 'album', 'photo') as $set) {
		foreach ($param[$itemId][$set] as $it) {
		    $field = $it['field'];
		    if (isset($viewType) && !$it[$viewType]) {
			continue;
		    }
		    if (isset($data[$itemId][$field])) {
			$result[$itemId][$field] = $data[$itemId][$field];
		    }
		    else if (isset($fillSet) && ($set == 'common' || $set == $fillSet)) {
			$result[$itemId][$field] = '';
		    }
		}
	    }
	}

	return array(null, $result, $param, $isContainer);
    }

    /**
     * Save custom field values for specified item, overwriting any existing values
     *
     * @param object GalleryEntity item
     * @param array (field => value)
     * @return GalleryStatus a status code
     * @static
     */
    function saveFieldValues(&$item, $fields) {
	$set = (GalleryUtilities::isA($item, 'GalleryAlbumItem'))
		? 1
		: ((GalleryUtilities::isA($item, 'GalleryPhotoItem'))
		  ? 2
		  : 0);
	$containerId = ($set == 1) ? $item->getId() : $item->getParentId();
	list ($ret, $param) =
	    GalleryCoreApi::fetchAllPluginParameters('module', 'map', $containerId);
	if ($ret) {
	    return $ret->wrap(__FILE__, __LINE__);
	}
	$isContainer = !empty($param);

	$ret = GalleryCoreApi::removeMapEntry('mapMap', array('itemId' => $item->getId()));
	if ($ret) {
	    return $ret->wrap(__FILE__, __LINE__);
	}
	foreach ($fields as $field => $value) {
	    if (!empty($value)) {
		$ret = GalleryCoreApi::addMapEntry('mapMap',
			array('itemId' => $item->getId(), 'field' => $field, 'value' => $value,
			      'setId' => $isContainer ? $containerId : 0, 'setType' => $set));
		if ($ret) {
		    return $ret->wrap(__FILE__, __LINE__);
		}
	    }
	}
	return null;
    }

    /**
     * Event handler for GalleryEntity::delete event
     * Remove any custom field values for entity being deleted.
     *
     * @see GalleryEventListener::handleEvent
     */
    function handleEvent($event) {

        GalleryCoreApi::requireOnce('modules/map/classes/GoogleMapUtilities.class');

        if ($event->getEventName() == 'GalleryEntity::delete') {
	    $item = $event->getEntity();
	    $ret = GalleryCoreApi::removeMapEntry('mapMap', array('itemId' => $item->getId()));
	    if ($ret) {
		return $ret->wrap(__FILE__, __LINE__);
	    }
	}
	if ($event->getEventName() == 'GalleryEntity::save') {
	    $item = $event->getEntity();
	    if ($item->getEntityType() == 'GalleryPhotoItem') {
		list ($ret, $coords) = GoogleMapUtilities::getGPSCoordsFromExif($item);
		if ($ret) {
		    return array($ret->wrap(__FILE__, __LINE__), null);
		}
  
		if ($coords != null) {
		    $fields['GPS'] = $coords;
		    $ret = mapHelper::saveFieldValues($item, $fields);
		    if ($ret) {
			return $ret->wrap(__FILE__, __LINE__);
		    }
		}
	    }
	}
	return array(null, null);
    }

    /**
     * Handler for Custom Field Admin actions
     *
     * @param mixed form data
     * @param int id of container, for album-specific settings
     * @return array GalleryStatus a status code
     *               mixed status to return from controller
     * @static
     */
    function handleAdminAction($form, $containerId = 0) {
	$status = array();

	if (isset($form['action']['save'])) {
	    list ($ret, $param) = mapHelper::loadParameters($containerId, false);
	    if ($ret) {
		return $ret->wrap(__FILE__, __LINE__);
	    }
	    foreach (array('common', 'album', 'photo') as $set) {
		$newParam[$set] = array();
		if (isset($form[$set]['index'])) {
		    foreach ($form[$set]['index'] as $newidx => $oldidx) {
			$newParam[$set][] =
				array('field' => $param[$set][$oldidx]['field'],
				      'summary' => isset($form[$set]['summary'][$newidx]),
				      'detail' => isset($form[$set]['detail'][$newidx]),
				      'choices' => $param[$set][$oldidx]['choices']);
		    }
		}
	    }
	    $ret = mapHelper::saveParameters($newParam, $containerId);
	    if ($ret) {
		return $ret->wrap(__FILE__, __LINE__);
	    }
	    $status['saved'] = 1;
	} else if (isset($form['action']['add'])) {
	    foreach ($form['action']['add'] as $set => $tmp) {
	    } /** @todo: Is this intended--empty action for foreach? */
	    $newField = str_replace('|', ':', str_replace('`', "&#039;", $form[$set]['newField']));
	    if (empty($newField)) {
		$status['error']['empty'] = 1;
		return array(null, $status);
	    }
	    list ($ret, $added) = mapHelper::addField($newField, $set, $containerId);
	    if ($ret) {
		return $ret->wrap(__FILE__, __LINE__);
	    }
	    if ($added) {
		$status['added'] = 1;
	    } else {
		$status['error']['duplicate'] = 1;
	    }
	} else if (isset($form['action']['go'])) {
	    foreach ($form['action']['go'] as $set => $tmp) {
	    } /** @todo: Is this intended--empty action for foreach? */
	    list ($ret, $param, $isContainer) = mapHelper::loadParameters($containerId, false);
	    if ($ret) {
		return $ret->wrap(__FILE__, __LINE__);
	    }
	    $idx = mapHelper::findParameter($param[$set], $form[$set]['goField']);
	    if ($idx < 0) {
		return array(GalleryCoreApi::error(ERROR_MISSING_OBJECT, __FILE__, __LINE__), null);
	    }
	    switch ($form[$set]['goAction']) {

	    case 'common':
		/* Remove from $set, add to common; no db change */
		$param['common'][] = $param[$set][$idx];
		unset($param[$set][$idx]);
		$ret = mapHelper::saveParameters(
			array('common' => $param['common'], $set => $param[$set]), $containerId);
		if ($ret) {
		    return $ret->wrap(__FILE__, __LINE__);
		}
		break;

	    case 'remove':
		/* Remove from $set; delete from all items */
		unset($param[$set][$idx]);
		$ret = mapHelper::saveParameters(array($set => $param[$set]), $containerId);
		if ($ret) {
		    return $ret->wrap(__FILE__, __LINE__);
		}
		$ret = mapHelper::deleteField($form[$set]['goField'],
					      $isContainer ? $containerId : 0);
                if ($ret) {
                     return $ret->wrap(__FILE__, __LINE__);
                }
		$status['removed'] = 1;
		break;

	    case 'album':
		/* Remove from common, add to album; delete from non-album items */
	    case 'photo':
		/* Remove from common, add to photo; delete from non-photo items */
		$newSet = $form[$set]['goAction'];
		$param[$newSet][] = $param[$set][$idx];
		unset($param[$set][$idx]);
		$ret = mapHelper::saveParameters(
			array('common' => $param['common'], $newSet => $param[$newSet]), 
			$containerId);
		if ($ret) {
		    return $ret->wrap(__FILE__, __LINE__);
		}
		$ret = mapHelper::deleteField($form[$set]['goField'],
					      $isContainer ? $containerId : 0, $newSet);
		if ($ret) {
		    return $ret->wrap(__FILE__, __LINE__);
		}
		break;

	    default:
		return array(GalleryCoreApi::error(ERROR_UNIMPLEMENTED, __FILE__, __LINE__), null);
	    }
	    if (empty($status)) {
		$status['moved'] = 1;
	    }
	} else if (isset($form['action']['picklist'])) {
	    $choices = array();
	    foreach (array_map('trim', explode("\n", $form['picklist'])) as $tmp) {
		if (!empty($tmp)) {
		    $choices[] = $tmp;
		}
	    }
	    list ($ret, $param) = mapHelper::loadParameters($containerId, false);
	    if ($ret) {
		return $ret->wrap(__FILE__, __LINE__);
	    }
	    foreach ($param as $set => $list) {
		$idx = mapHelper::findParameter($list, $form['pickField']);
		if ($idx >= 0) {
		    $param[$set][$idx]['choices'] = $choices;
		    $ret = mapHelper::saveParameters(array($set => $param[$set]), $containerId);
		    if ($ret) {
			return $ret->wrap(__FILE__, __LINE__);
		    }
		    $status['picklist'] = 1;
		    break;
		}
	    }
	} /* else $form['action']['reset'] */

	return array(null, $status);
    }

    /**
     * Load form data for Admin template
     *
     * @param mixed form
     * @param int id of container, for album-specific settings
     * @return object GalleryStatus a status code
     * @static
     */
    function loadAdminForm(&$form, $containerId = 0) {
	global $gallery;
	list ($ret, $module) = GalleryCoreApi::loadPlugin('module', 'map');
	if ($ret) {
	    return $ret->wrap(__FILE__, __LINE__);
	}

	$form['set'] = array();
	$form['set'][] = array('key' => 'common', 'name' => $gallery->i18n('Common Fields'));
	$form['set'][] = array('key' => 'album', 'name' => $gallery->i18n('Album Fields'));
	$form['set'][] = array('key' => 'photo', 'name' => $gallery->i18n('Photo Fields'));

	list ($ret, $form['fields']) = mapHelper::loadParameters($containerId, false);
	if ($ret) {
	    return $ret->wrap(__FILE__, __LINE__);
	}

	return null;
    }

    /**
     * @see mapInterface_1_0::createmaps()
     */
    function createmaps($fieldNames, $containerId = 0) {
	$duplicates = array();
	foreach ($fieldNames as $fieldName) {
	    list ($ret, $added) = mapHelper::addField($fieldName, 'common', $containerId);
	    if ($ret) {
		return $ret->wrap(__FILE__, __LINE__);
	    }
	    if (!$added) {
		$duplicates[] = $fieldName;
	    }
	}
	return array(null, $duplicates);
    }

    /**
     * @see mapInterface_1_0::setmapValues()
     */
    function setmapValues($itemId, $data) {
	list ($ret, $item) = GalleryCoreApi::loadEntitiesById($itemId);
	if ($ret) {
	    return $ret->wrap(__FILE__, __LINE__);
	}
	$ret = mapHelper::saveFieldValues($item, $data);
	if ($ret) {
	    return $ret->wrap(__FILE__, __LINE__);
	}
	return null;
    }

    /**
     * Get all the Google API key profiles.
     *
     * @return array GalleryStatus a status code
     *               array Google API key profiles
     */
    function getAllKeyProfiles() {
	list ($ret, $mapKeys) = GalleryCoreApi::getPluginParameter('module', 'map', 'mapKeys');
	if ($ret) {
	    return array($ret, null);
	}
	return array(null, ($mapKeys != '') ? unserialize($mapKeys) : array());
    }
    
    /**
     * Retrieve the Google API key for the current URL, or empty string if none.
     *
     * @return array GalleryStatus a status code
     * 	             string Google API key which matches the detected current URL
     */
    function fetchApiKey() {
	global $gallery;
	
	$urlGenerator =& $gallery->getUrlGenerator();

	/* Grab the current URL directory */
	$urlDir = $urlGenerator->getCurrentUrlDir();
	list ($ret, $profile) = mapHelper::fetchKeyProfileForUrl($urlDir);
	if ($ret) {
	    return array($ret, null);
	}
	$key = (array_key_exists('apiKey', $profile)) ? $profile['apiKey'] : '';

	return array($ret, $key);
    }
    
    /**
     * Retrieve the API key profile for the given URL, or empty array if none.
     *
     * @param $url URL to match against the stored profiles. Directory only, no URI.
     * @return array GalleryStatus a status code
     * 	             array Google API key profile which matches the provided URL
     */
    function fetchKeyProfileForUrl($url) {
	$profile = array();

	/* Get the key profiles and test each one against the passed URL. */
	list ($ret, $allKeySets) = mapHelper::getAllKeyProfiles();
	if ($ret) {
	    return array($ret, null);
	}

	$index = mapHelper::_matchLongestUrl($allKeySets, $url);
	if ($index != -1) {
	    $profile = $allKeySets[$index];
	}

	return array(null, $profile);
    }

    /**
     * Remove the API key profile associated with the given URL.
     *
     * @param $url URL to match against the stored profiles. Directory only, no URI.
     * 
     * @return array GalleryStatus a status code
     *               boolean delete was successful
     */
    function deleteKeyProfile($url) {
	/*
	 * Get the key profiles and test each one against the passed URL. Delete the matching one.
	 */
	list ($ret, $allKeySets) = mapHelper::getAllKeyProfiles();
	if ($ret) {
	    return array($ret, false);
	}

	$index = mapHelper::_matchLongestUrl($allKeySets, $url);
	if ($index != -1) {
	    unset($allKeySets[$index]);
	}

	$ret = mapHelper::_saveAllKeyProfiles($allKeySets);
	return array($ret, $found);
    }

    /**
     * Save the given Google API key profile in the database.
     *
     * @param $name Name of the profile
     * @param $url URL for the profile
     * @param $apiKey Google API key for the profile
     * @param $oldUrl Url of old profile to replace if editing, or blank if new
     * 
     * @return GalleryStatus a status code
     */
    function saveKeyProfile($name, $url, $apiKey, $oldUrl) {
	/* Get all the key profiles. */
	list ($ret, $allKeySets) = mapHelper::getAllKeyProfiles();
	if ($ret) {
	    return array($ret, null);
	}
	$addNew = false;

	if (!empty($oldUrl)) {
	    /* If we're editing a key, locate it by the oldUrl and modify the saved profile.
	     * If no match, then add a new profile.
	     */
	    $index = mapHelper::_matchLongestUrl($allKeySets, $oldUrl);
	    if ($index != -1) {
		$allKeySets[$index]['url'] = $url;
		$allKeySets[$index]['name'] = $name;
		$allKeySets[$index]['apiKey'] = $apiKey;
	    } else {
	    	$addNew = true;
	    }
	} else {
	    $addNew = true;
	}
	if ($addNew) {
	    /* Add a new key profile */
	    $allKeySets[] = array('url' => $url, 'name' => $name, 'apiKey' => $apiKey);
	}
	$ret = mapHelper::_saveAllKeyProfiles($allKeySets);
	return $ret;
    }
    
    /**
     * Find the profile index of the longest matching url in the Google API key profiles in the database.
     *
     * @param $profiles array Google API key profiles
     * @param $url Url to find longest match
     *  
     * @return integer index of longest matching url profile, or -1 if none found
     */
    function _matchLongestUrl($profiles, $url) {
	$longestMatch = 0;
	$matchIndex = -1;

	foreach ($profiles as $index => $keySet) {
	    /* 
	     * Go through all the keys and pick the longest (most-specific) match, in case more than
	     * one key applies to the given url. Use a case-insensitive compare. Could conceivably
	     * give a false match if URL contains a path after the host name, if the path is 
	     * case-sensitive, but that's a very unlikey situation.
	     */
	    $length = strlen($keySet['url']);
	    if (!strncasecmp($url, $keySet['url'], $length) && $length > $longestMatch) {
		$matchIndex = $index;
		$longestMatch = $length;
	    }
	}
	return $matchIndex;
    }
    
    /**
     * Save the Google API key profiles in the database.
     *
     * @param $profiles array Google API key profiles
     * 
     * @return GalleryStatus a status code
     */
    function _saveAllKeyProfiles($profiles) {
    	$ret = GalleryCoreApi::setPluginParameter('module', 'map', 'mapKeys', serialize($profiles));
    	
    	return $ret;
    }
    
    /**
     * Get an item color in the DB
     *
     * @param $itemId integer the item ID
     * @return array  GalleryStatus a status code
     *	              string Item color
     *
     */
    function getItemColor($itemId){
	global $gallery;

	$query = '
	SELECT 
	  [mapMap::value]
	FROM [mapMap]
	WHERE
	  [mapMap::field] = \'Color\'
	  AND
	  [mapMap::itemId] = ?
	';
	    
	list ($ret, $results) = $gallery->search($query, array($itemId), array());
	if ($ret or $results->resultCount() == 0) {
	    return "default";
	}
		
	$Color = $results->nextResult();

	return $Color[0];
		
    }

    /**
     * Get an item zoomlevel in the DB
     *
     * @param $itemId integer the item ID
     * @return zoomlevel of item
     *
     */
    function getItemZoomLevel($itemId){
	global $gallery;

	list ($ret, $defaultzoomlevel) = GalleryCoreApi::getPluginParameter('module', 'map', 'zoomInLevel');
	if ($ret) {
	    return "4";
	}

	$query = '
	SELECT 
	  [mapMap::value]
	FROM [mapMap]
	WHERE
	  [mapMap::field] = \'ZoomLevel\'
	  AND
	  [mapMap::itemId] = ?
	';
	    
	list ($ret, $results) = $gallery->search($query, array($itemId), array());
	if ($ret or $results->resultCount() == 0) {
	    return $defaultzoomlevel;
	}
		
	$ZoomLevel = $results->nextResult();

	return $ZoomLevel[0];
		
    }


    /**
     * Get an item GPS Coordinates from the DB
     *
     * @param $itemId integer the item ID
     * @return coordinates of item
     *
     */
	function getItemGPSCoordinatesFromDB($itemId){
		global $gallery;

	    $query = '
	       SELECT 
		       [mapMap::value]
		   FROM [mapMap]
           WHERE [mapMap::field] = \'GPS\' AND [mapMap::itemId] = ?
	    ';
	    
	    list ($ret, $results) = $gallery->search($query, array($itemId), array());
		if ($ret or $results->resultCount() == 0) {
			return null;
		}
		
		$Coordinates = $results->nextResult();

		return $Coordinates[0];
		
	}

    /**
     * Create an array with item properties to be used to display on the map
     *
     * @param $itemId integer the itemId
     * @return array  GalleryStatus a status code
     *				  null or array of item properties
     *
     */
    function _getPropertiesForItemId($itemId){
    	
    	global $gallery;
    	$gurl =& $gallery->getUrlGenerator();
    	$properties = array();
    	
    	list ($ret, $mapThumbHeight) = GalleryCoreApi::getPluginParameter('module', 'map', 'ThumbHeight');
    	if ($ret) {
			return array ($ret, null);
		}
    	
		/* Get the item */
		list ($ret, $item) = GalleryCoreApi::loadEntitiesById($itemId);
		if ($ret) {
			return array($ret, null);
		}
		/* Get the thumbnail information */
		list ($ret, $thumb) = GalleryCoreApi::fetchThumbnailsByItemIds(array($itemId));
		if ($ret) {
			return array($ret, null);
		}
		/* Get the date format */
		list ($ret, $dateFormat) = 
			GalleryCoreApi::getPluginParameter('module', 'core', 'format.date');
		if ($ret) {
			return array($ret, null);
		}
		
		$itemTitle = $item->getTitle();
		
		$properties = array(
		    'type' => $item->getEntityType(),
		    'title' => (empty($itemTitle)) ? 
				preg_replace(array('/\n/', '/\r/'), array('', ''), $item->getPathComponent()) : 
				preg_replace(array('/\n/', '/\r/'), array('', ''), $itemTitle),
		    'summary' => preg_replace(array('/\n/', '/\r/'), array('', ''),
				$item->getSummary()),
		    'description' => preg_replace(array('/\n/', '/\r/'), array('', ''),
				$item->getDescription()),
		    'created' => strftime($dateFormat, $item->getOriginationTimestamp())
		);
		
		if (array_key_exists($itemId, $thumb)) {
			/* Add the Thumbnail Info to the array */
			$pointThumb = $thumb[$itemId];
			$properties['thumbLink'] = 
				$gurl->generateUrl(
					array('view' => 'core.DownloadItem',
					      'itemId' => $pointThumb->getId(),
					      'serialNumber' => $pointThumb->getSerialNumber()),
					      array('forceFullUrl' => true));
			$properties['thumbWidth'] = $pointThumb->getWidth();
			$properties['thumbHeight'] = $pointThumb->getHeight();
		} else {
			/* No Thumbnail Information */
			$properties['thumbLink'] = '';
			$properties['thumbWidth'] = '100';
			$properties['thumbHeight'] = '100';
		}
		
		/* Set the Thumbnail Bar Sizes */
	    $properties['thumbbarWidth'] = 
			$mapThumbHeight * $properties['thumbWidth'] / $properties['thumbHeight'];
	    $properties['thumbbarHeight'] = 
			$mapThumbHeight * $properties['thumbHeight'] / $properties['thumbWidth'];

		
		return array (null, $properties);
	}
    

    /**
     * Get all the GPS coordinates stored in the database
     *
     * @param none
     * @return array  GalleryStatus a status code
     *				  null or array of items
     *
     */
    function getGPSItems() {
	global $gallery;
	$gurl =& $gallery->getUrlGenerator();

	/* Only retrieve items that we have permissions to */
	list ($ret, $aclIds) = GalleryCoreApi::fetchAccessListIds('core.view', $gallery->getActiveUserId());
	if ($ret) {
	    return array ($ret, null);
	}
	if (empty($aclIds)) {
	    return array ($ret, null);
	}
	$aclMarkers = GalleryUtilities::makeMarkers(count($aclIds));

	$query = '
	SELECT 
	  [mapMap::itemId], [mapMap::value]
	FROM 
	  [mapMap], [GalleryAccessSubscriberMap]
	WHERE 
	  [mapMap::field] = \'GPS\' 
	AND
	  SUBSTRING([mapMap::itemId],1,1) <> \'G\'
	AND
	  [GalleryAccessSubscriberMap::itemId] = [mapMap::itemId]
	AND
	  [GalleryAccessSubscriberMap::accessListId] in (' . $aclMarkers . ')
	';

	list ($ret, $results) = $gallery->search($query, $aclIds, array());
	if ($ret or $results->resultCount() == 0) {
	    return array($ret, array());
	}

	$items = array();

	while ($result = $results->nextResult()) {

	    list ($ret, $item) = GalleryCoreApi::loadEntitiesById($result[0]);			
	    if ($ret) {
		return array($ret, null);
	    }

	    $explodedCoord = explode(',', $result[1]);
	    $itemLink = $gurl->generateUrl(
		    array('view' => 'core.ShowItem', 'itemId' => $result[0]),
		    array('forceFullUrl' => true));

	    $items[$result[0]] = array(
		'id' => $result[0],
		'gps' => $result[1],
		'color' => mapHelper::getItemColor($result[0]),
		'zoomlevel' => mapHelper::getItemZoomLevel($result[0]),
		'itemLink' => $itemLink,
		'parentId' => $item->getParentId(),
		'hasChild' => false,
		'posx' => $explodedCoord[0],
		'posy' => $explodedCoord[1]
		);

	    list ($ret, $additionalProperties) = mapHelper::_getPropertiesForItemId($result[0]);
	    if ($ret) {
		return array ($ret, null);
	    }

	    $items[$result[0]] = $items[$result[0]] + $additionalProperties;
	}

	return array(null, $items);
    }
	
    /**
     * Private function to make an array out of the Groups from the Database save
     *
     * @param none
     * @return array  GalleryStatus a status code
     *				  null or array of Groups
     *
     */

	function _getGroupsFromDB()  {
		global $gallery;
		$gurl =& $gallery->getUrlGenerator();
		$platform =& $gallery->getPlatform();
		
		$groups = array();
		
		/* Get the date format */
		list ($ret, $dateFormat) = 
			GalleryCoreApi::getPluginParameter('module', 'core', 'format.date');
		if ($ret) {
			return array($ret, null);
		}

		list ($ret, $tmpparam) =
  		    GalleryCoreApi::getPluginParameter('module', 'map', 'MapGroups');
  		if ($ret) {
			return array ($ret, null);
		}
		$tmpgroups = explode('|', $tmpparam);

		foreach ($tmpgroups as $tmpgroup) {
		    $groupinfo = explode('`', $tmpgroup);

			$thumbpic = substr(dirname(__FILE__),0,-7). 'images/groups/' . $groupinfo[4];
			$Tsizes = $platform->getimagesize($thumbpic);
			if ($Tsizes !== false) {
				$thumbWidth = $Tsizes[0];
				$thumbHeight = $Tsizes[1];
				$thumbbarWidth = ($Tsizes[1] != 0) ? $Tsizes[0] / $Tsizes[1] : 1;
				$thumbbarHeight = ($Tsizes[0] != 0) ? $Tsizes[1] / $Tsizes[0] : 1;
			} else {
				$thumbWidth = $thumbHeight = $thumbbarWidth = $thumbbarHeight = 1;
			}
			
			$groups["G".$groupinfo[0]] = array(
		        'id' => "G".$groupinfo[0],
		        'title' => $groupinfo[1],
		        'description' => $groupinfo[3],
		        'summary' => $groupinfo[2],
		        'created' => strftime($dateFormat, $groupinfo[5]),
		        'thumbLink' => GalleryUtilities::convertPathToUrl($thumbpic,
					array('forceFullUrl' => true, 'forceDirect' => true)),
				'thumbWidth' => $thumbWidth,
				'thumbHeight' => $thumbHeight,
				'thumbbarWidth' => $thumbbarWidth,
				'thumbbarHeight' => $thumbbarHeight,
			);
			
		}
		
		return array (null, $groups);
	}
	

    /**
     * Get all the GPS coordinates stored in the database
     *
     * @param none
     * @return array  GalleryStatus a status code
     *				  null or array of items
     *
     */
	function getGPSGroups() {
		global $gallery;
		$gurl =& $gallery->getUrlGenerator();
				
    	list ($ret, $mapThumbHeight) = GalleryCoreApi::getPluginParameter('module', 'map', 'ThumbHeight');
    	if ($ret) {
			return array ($ret, null);
		}

	    $query = '
	       SELECT 
			   [mapMap::itemId], [mapMap::value]
		   FROM 
		       [mapMap]
           WHERE
		       [mapMap::field] = \'GPS\' 
		   AND 
		       SUBSTRING([mapMap::itemId],1,1) = \'G\'
	    ';
	    
	    list ($ret, $results) = $gallery->search($query, array(), array());
		if ($ret or $results->resultCount() == 0) {
			return array($ret, array());
		}
		
		$items = array();
		list ($ret, $groupsinfos) = mapHelper::_getGroupsFromDB();
		if ($ret) {
			return array ($ret, null);
		}

		while ($result = $results->nextResult()) {
						
			$explodedCoord = explode(",", $result[1]);
			$itemLink = $gurl->generateUrl(
			    array('view' => 'map.ShowMap', 'Group' => $result[0]),
			    array('forceFullUrl' => true));
			
			$items[$result[0]] = array(
			    'id' => $result[0],
				'gps' => $result[1],
				'color' => mapHelper::getItemColor($result[0]),
				'zoomlevel' => mapHelper::getItemZoomLevel($result[0]),
				'itemLink' => $itemLink,
			    'title' => $groupsinfos[$result[0]]['title'],
			    'description' => $groupsinfos[$result[0]]['description'],
			    'summary' => $groupsinfos[$result[0]]['summary'],
			    'created' => $groupsinfos[$result[0]]['created'],
			    'thumbLink' => $groupsinfos[$result[0]]['thumbLink'],
				'thumbWidth' => $groupsinfos[$result[0]]['thumbWidth'],
				'thumbHeight' => $groupsinfos[$result[0]]['thumbHeight'],
				'thumbbarWidth' => $groupsinfos[$result[0]]['thumbbarWidth'] * $mapThumbHeight,
				'thumbbarHeight' => $groupsinfos[$result[0]]['thumbbarHeight'] * $mapThumbHeight,
				'regroupShowHigh' => 0,
				'regroupShowLow' => 19,
				'parentDist' => -1,
				'hasHiddenChild' => false,
				'group' => -1,
				'type' => 'GoogleMapGroup',
				'display' => true,
				'posx' => $explodedCoord[0],
				'posy' => $explodedCoord[1]
			);
		}
		
		return array(null, $items);
	}

    /**
     * Create the parentsequence array
     *
     * @param $items array the items for which to get the parent sequence
     *		  $LevelFilterRoot the level to filter the root at
	 *		  $LevelFilterAll the level to filter all other items
	 *		  $albumfilter	true to enable albumfilters
     * @return array  GalleryStatus a status code
     *				  null or array of parentsequences
     *
     */
	function getParentSequence($items, $LevelFilterRoot, $LevelFilterAll, $albumfilter) {
		$parents = array();
		
		/* Grab the ID of the root album */
		list ($ret, $TheRoot) =
			GalleryCoreApi::getPluginParameter('module', 'core', 'id.rootAlbum');
		if ($ret) {
			return array ($ret, null);
		}
			
		foreach ($items as $id => $currentitem) {
		    if ($id != $TheRoot) {
			    /* retrieve the "parent" sequence for each item (except groups and root album) */
			    list ($ret, $parents[$id]) =
				    GalleryCoreApi::fetchParentSequence($id);
		        if ($ret) {
					return array ($ret, null);
				}
			    list ($ret, $albuminfos) = GalleryCoreApi::loadEntitiesById($parents[$id]);
		        if ($ret) {
					return array ($ret, null);
				}

   			    list ($ret, $RootAlbumName) = GalleryCoreApi::loadEntitiesById($TheRoot);
		        if ($ret) {
					return array ($ret, null);
				}
 	 		    if ($LevelFilterRoot == 1 and $albumfilter == $RootAlbumName->getTitle()) {
			        $fromLevel = count($parents[$id]) - 1;
	     		} else if ($LevelFilterAll > 0) {
			        $fromLevel = (count($parents[$id]) - $LevelFilterAll >= 0)
					    ? count($parents[$id]) - $LevelFilterAll : 0;
			    } else {
			    $fromLevel = 0;
			    }

			    /* get item and parent id */
		        list($ret, $item) = GalleryCoreApi::loadEntitiesById($id);
		        if ($ret) {
					return array ($ret, null);
				}
				$parentId = $parents[$id][count($parents[$id])-1];

				for ($i = $fromLevel; $i < count($parents[$id]); $i++) {
			    	$parents[$id][$i] = ($albuminfos[$i]->getTitle() != "") ? $albuminfos[$i]->getTitle(): $albuminfos[$i]->getPathComponent();
				}
				if ($fromLevel > 0) {
			    	for ($i = 0; $i < $fromLevel; $i++) {
						array_shift($parents[$id]);
			    	}
				}
			}			
		}

		return array(null, $parents);
	}


    /**
     * Get the distance in pixel between 2 coordinates for a specific zoom level
     *
     * @param $point1 string the coordinates for the first point (lat, lon)
     *		  $point2 string the coordinates for the second point (lat, lon)
	 *		  $zoomleve	the zoomlevel at which the calculation is made
     * @return flot distance in pixels
     *
     */

    function PixelDistance($point1, $point2, $zoomlevel) {
    	
		$tmp1 = explode(',', $point1);
		$tmp2 = explode(',', $point2);
		$f = M_PI / 180;
		$d = acos(sin($tmp1[0] * $f) * sin($tmp2[0] * $f) + cos($tmp1[0] * $f) * cos($tmp2[0] * $f)
			* cos($tmp2[1] * $f - $tmp1[1] * $f)) * 6371;
		$fact = (40074 * (cos($tmp2[0] * $f))) / 256 / pow(2, $zoomlevel);
		$pixdist = round($d / $fact);
		
		return $pixdist;
    }
    
    /**
     * Get the number of items for a specific album 
     *
     * @param $itemId integer the ID of the item, null will used the root album
     * @return array GalleryStatus
     *				 $count, an integer
     *
     */
    
    function getCountItemWithCoords ($itemId = null) {
	global $gallery;
	$userId = $gallery->getActiveUserId();
        
	if ($itemId == null) {
	    list ($ret, $itemId) = 
		GalleryCoreApi::getPluginParameter('module', 'core', 'id.rootAlbum');
	    if ($ret) {
    		return array($ret, null);
	    }
	}

	if (empty($itemId)){
	    return array(GalleryCoreApi::error(ERROR_BAD_PARAMETER, __FILE__, __LINE__), null);
	}
        
	list($ret, $item) = GalleryCoreApi::loadEntitiesById($itemId);
	if ($ret) {
	    return array($ret, null);
	}
        
	list ($ret, $itemIds) = GalleryCoreApi::fetchDescendentItemIds($item, null, null, 'core.view');
	if ($ret) {
	    return array($ret, null);
	}
		
	
	if (empty($itemIds)){
	    return array (null, 0);
	}
	
	$query='
	SELECT
	 count([mapMap::itemId])
	FROM
	 [mapMap]
	WHERE
	 [mapMap::itemId] IN (' . GalleryUtilities::makeMarkers(count($itemIds)) . ')
	';

	list ($ret, $searchResults) = $gallery->search($query, $itemIds);
	if ($ret) {
	    return array($ret, null);
	}
		
	$count = $searchResults->nextResult();

	return array(null, $count[0]);
    }


    /**
     * Get the routes stored in the database
     * Also creates the Numbered markers if needed
     *
     * @param 	$Points the array of point shown on the map
     *			$EnableRouteNumbering boolean to use route numbering or not
     *			$MarkerSets list of Marker Sets selected per item type
     *			$DefaultColor list of Default colors per item type
     * @return array GalleryStatus
     *				 $routes array of routes
     *
     */
    function getRoutes ($Points, $EnableRouteNumbering = false, $MarkerSets, $DefaultColors) {
	global $gallery;
	$platform =& $gallery->getPlatform();
		
	list ($ret, $DBRoutes) = GalleryCoreApi::getPluginParameter('module', 'map', 'Routes');
	if ($ret) {
	    return array ($ret, null);
	}
	list ($ret, $impath) = GalleryCoreApi::getPluginParameter('module', 'imagemagick', 'path');
	if ($ret) {
	    return array($ret, null);
	}
	if (empty($impath)) {
	    $EnableRouteNumbering = false;
	}

	$mapModBaseDir = substr(dirname(__FILE__),0,-7);
		
	$allrouteparam = array();
	$routeitems = array();
	$routes = explode('|', $DBRoutes);
	foreach ($routes as $route) {
	    $tmppoint = array();
	    $tmpparam = array();
	    $rawitem = array();
	    $routeinfo = explode('`', $route);
	    for ($i = 0; $i < 7; $i++) {
		$tmpparam[] = $routeinfo[$i];
	    }

	    GalleryUtilities::guaranteeDirExists($mapModBaseDir . 'images/routes/' . $routeinfo[1]);

	    $nb = 0;

	    for ($i = 7; $i < count($routeinfo); $i++) {
		if (in_array($routeinfo[$i], array_keys($Points))) {
		    $rawitem[] = $routeinfo[$i];
		    $nb++;
		    if ($EnableRouteNumbering) {
			/* Get info on the item to create the "route numerical marker" */
			list ($ret, $item) = GalleryCoreApi::loadEntitiesById($routeinfo[$i]);
			if ($ret) {
			    return array ($ret, null);
			}
			$type = $item->getEntityType();
			$imagename = $MarkerSets[$type];
			$defaultcolor = $DefaultColors[$type];
			$color = mapHelper::getItemColor($routeinfo[$i]);
			$color = ($color == "default") ? $defaultcolor : $color;

			$sourceimage = $mapModBaseDir . 'images/markers/' . $imagename
					. '/marker_' . strtoupper($color) . '.png';
			$destination = $mapModBaseDir . 'images/routes/' . $routeinfo[1] . '/'
					. $nb . '-marker_' . strtoupper($color) . '.png';
		
			$picsize = $platform->getimagesize($sourceimage);
		
			$xpos = $picsize[0] / 2 - 3;
			$ypos = $picsize[1] / 2 + 2;
			/**
			 * @todo Change this to use ImageMagick's "annotate" instead of 
			 * "draw text".
			 * Can't do it yet because ImageMagick 6 is required.
			 */
			/* ImageMagick's convert is picky about the format used for the
			 * -draw text argument and how it's quoted, so note the extra double
			 * quotes used before text and after the text to be drawn ($nb), and 
			 * the single quotes around the text to be drawn on the image.
			 */
			$command = array($impath . 'convert',
					 $sourceimage,
					 '-draw',
					 '"text',
					 $xpos . ',' . $ypos,
					 '\'' . $nb . '\'"',
					 $destination);
			$returnstuff = $platform->exec(array($command));
						
		    }
		    /*
		     * for each item, grab the coordinates and store them in an array.
		     */
		    $tmppoint[] = explode(',', mapHelper::getItemGPSCoordinatesFromDB($routeinfo[$i]));
		}
	    }
	    $routeitems[$routeinfo[1]] = $rawitem;
	    $tmpparam[] = $tmppoint;
	    $allrouteparam[] = $tmpparam;
	}
	return array (null, $allrouteparam, $routeitems);
    }
}
?>
